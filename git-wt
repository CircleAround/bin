#!/usr/bin/env bash
# git-wt  ‚îÄ manage worktrees at ../<repo>.worktrees/<number>
set -euo pipefail

usage() {
  cat << 'EOF'
Usage: git-wt [command] [args]

Commands:
  git-wt add <branch>  Create worktree with branch
  git-wt pop [num]     Remove worktree by number (defaults to highest)
  git-wt goto <num>    Copy cd command to clipboard (0=main, 1-9=worktree)
  git-wt               Show interactive menu

Examples:
  git-wt add feature-x  Create worktree in directory "1" with branch "feature-x"
  git-wt pop            Remove highest numbered worktree
  git-wt pop 2          Remove worktree directory "2"
  git-wt goto 0         Copy cd command to main repository
  git-wt goto 1         Copy cd command to worktree 1
  git-wt                Interactive menu with add/pop/help/exit options
EOF
  exit 1
}

# Sanitize branch name to prevent injection attacks
sanitize_branch_name() {
  local branch="$1"
  # Remove dangerous characters and validate
  if [[ "$branch" =~ [^a-zA-Z0-9._/-] ]]; then
    echo "‚ùå Branch name contains invalid characters. Use only: a-z A-Z 0-9 . _ / -" >&2
    exit 1
  fi
  if [[ "$branch" =~ ^[.-] || "$branch" =~ [.-]$ || "$branch" =~ // ]]; then
    echo "‚ùå Invalid branch name format" >&2
    exit 1
  fi
}

# Find the maximum numbered worktree directory
find_max_worktree_num() {
  local max_num=0
  [[ -d "$wroot" ]] || return 1
  
  # Enable nullglob to handle case where no files match pattern
  local nullglob_was_set=false
  shopt -q nullglob && nullglob_was_set=true
  shopt -s nullglob
  
  for dir in "$wroot"/*; do
    [[ -d "$dir" ]] || continue
    local num=$(basename "$dir")
    [[ "$num" =~ ^[1-9]$ ]] && ((num > max_num)) && max_num=$num
  done
  
  # Restore original nullglob setting
  $nullglob_was_set || shopt -u nullglob
  
  [[ $max_num -eq 0 ]] && return 1
  echo "$max_num"
}

# Check for uncommitted changes and ask for confirmation
check_worktree_changes() {
  local target="$1"

  # Change to the worktree directory and check for differences
  local has_changes=false

  # Check if directory exists and is a git worktree
  [[ -d "$target" ]] || return 0

  # Save current directory and change to worktree
  local original_pwd="$PWD"
  cd "$target" || return 0

  # Check for staged changes
  if ! git diff --cached --quiet 2>/dev/null; then
    has_changes=true
  fi

  # Check for unstaged changes
  if ! git diff --quiet 2>/dev/null; then
    has_changes=true
  fi

  # Check for untracked files
  if [[ -n "$(git ls-files --others --exclude-standard 2>/dev/null)" ]]; then
    has_changes=true
  fi

  # Return to original directory
  cd "$original_pwd"

  if [[ "$has_changes" == true ]]; then
    echo "‚ö†Ô∏è The worktree has uncommitted changes:"
    echo "   Location: $target"
    echo ""

    # Show the changes
    cd "$target"
    echo "üìÑ Current status:"
    git status --short 2>/dev/null || true
    cd "$original_pwd"
    echo ""

    # Ask for confirmation
    read -rp "‚ùì Are you sure you want to remove this worktree? [y/N]: " confirm
    case "$confirm" in
      y|Y|yes|YES)
        echo "üóëÔ∏è Proceeding with removal..."
        return 0
        ;;
      *)
        echo "‚ùå Removal cancelled"
        return 1
        ;;
    esac
  fi

  return 0
}

# Safely remove worktrees directory if it only contains numbered directories
cleanup_worktrees_dir() {
  [[ -d "$wroot" ]] || return 0
  
  # Check if directory contains only numbered directories (1-9) or is empty
  local has_non_numbered=false
  local has_anything=false
  
  for item in "$wroot"/*; do
    [[ -e "$item" ]] || continue
    has_anything=true
    
    local basename_item=$(basename "$item")
    if [[ ! "$basename_item" =~ ^[1-9]$ ]] || [[ ! -d "$item" ]]; then
      has_non_numbered=true
      break
    fi
  done
  
  if [[ "$has_non_numbered" == true ]]; then
    echo "‚ö†Ô∏è Cannot remove worktrees directory: contains non-numbered files/directories" >&2
    echo "   Please manually clean: $wroot" >&2
    return 1
  elif [[ "$has_anything" == false ]]; then
    # Directory is empty, safe to remove
    rmdir "$wroot"
    echo "üóëÔ∏è Removed empty worktrees directory: $wroot"
    return 0
  fi
  
  # Has numbered directories, don't remove
  return 0
}

# Copy files from main branch to worktree based on .git-wt.conf
copy_files_to_worktree() {
  local target="$1"
  local config_file="$root/.git-wt.conf"

  # Skip if config file doesn't exist
  [[ -f "$config_file" ]] || return 0

  local copied_count=0

  # Read each line from config file
  while IFS= read -r file_path || [[ -n "$file_path" ]]; do
    # Skip empty lines and comments
    [[ -z "$file_path" || "$file_path" =~ ^[[:space:]]*# ]] && continue

    # Trim whitespace
    file_path="${file_path#"${file_path%%[![:space:]]*}"}"
    file_path="${file_path%"${file_path##*[![:space:]]}"}"

    [[ -z "$file_path" ]] && continue

    # Check if source file or directory exists
    if [[ -f "$root/$file_path" ]]; then
      # Create directory structure in target
      mkdir -p "$target/$(dirname "$file_path")"

      # Copy file
      cp "$root/$file_path" "$target/$file_path"
      echo "üìÑ Copied file: $file_path"
      copied_count=$((copied_count + 1))
    elif [[ -d "$root/$file_path" ]]; then
      # Create parent directory structure in target
      mkdir -p "$target/$(dirname "$file_path")"

      # Copy directory recursively
      cp -r "$root/$file_path" "$target/$file_path"
      echo "üìÅ Copied directory: $file_path"
      copied_count=$((copied_count + 1))
    else
      echo "‚ö†Ô∏è Warning: File or directory not found, skipping: $file_path" >&2
    fi
  done < "$config_file"

  if [[ $copied_count -gt 0 ]]; then
    echo "‚úÖ Copied $copied_count files from configuration"
  fi
}

# Create new worktree with given branch name
create_worktree() {
  local branch="$1"

  # Sanitize branch name
  sanitize_branch_name "$branch"

  # Find next available number (maximum 9)
  local next_num=1
  while [[ $next_num -le 9 && -e "$wroot/$next_num" ]]; do
    ((next_num++))
  done

  if [[ $next_num -gt 9 ]]; then
    echo "‚ùå Maximum 9 worktrees allowed. Please remove one first with: git-wt pop" >&2
    exit 1
  fi

  local target="$wroot/$next_num"
  mkdir -p "$wroot"

  # Track if branch exists remotely, otherwise create new
  if git show-ref --verify --quiet "refs/heads/$branch"; then
    git worktree add "$target" "$branch" || { rmdir "$target" 2>/dev/null; exit 1; }
  elif git ls-remote --exit-code --heads origin "$branch" &>/dev/null; then
    git worktree add "$target" "origin/$branch" || { rmdir "$target" 2>/dev/null; exit 1; }
  else
    git worktree add -b "$branch" "$target" || { rmdir "$target" 2>/dev/null; exit 1; }
  fi

  echo "‚úÖ Worktree created: $target (branch: $branch)"

  # Copy files from configuration
  copy_files_to_worktree "$target"

  git worktree list

  # Show command to navigate to new directory
  echo ""
  echo "üìÅ To navigate to the new directory:"
  echo "cd \"$target\""
}

# ‚ë† Check if this is a Git repository
git rev-parse --is-inside-work-tree &>/dev/null || {
  echo "‚ùå Not a Git repository" >&2; exit 1; }

# ‚ë° Calculate paths (common)
# Get main repository path (works from both main repo and worktrees)
git_common_dir="$(git rev-parse --git-common-dir)"
root="$(dirname "$git_common_dir")"
repo="$(basename "$root")"
wroot="$root/../${repo}.worktrees"

# ‚ë¢ Subcommand processing
command="${1-}"
case "$command" in
  -h|--help) usage ;;
  pop)
    shift
    # pop subcommand processing
    target_num="${1-}"
    
    # Check if worktree directory exists
    [[ -d "$wroot" ]] || { echo "‚ùå Worktree directory does not exist: $wroot"; exit 1; }
    
    # If no number specified, find the maximum number
    if [[ -z "$target_num" ]]; then
      if ! target_num=$(find_max_worktree_num); then
        echo "‚ùå No removable worktree found"
        exit 1
      fi
    fi
    
    target="$wroot/$target_num"
    [[ -d "$target" ]] || { echo "‚ùå Worktree does not exist: $target"; exit 1; }

    # Check for changes and ask for confirmation if needed
    if ! check_worktree_changes "$target"; then
      exit 1
    fi

    # Remove worktree (force removal if user confirmed despite changes)
    if ! git worktree remove "$target" 2>/dev/null; then
      git worktree remove --force "$target"
    fi
    echo "‚úÖ Worktree removed: $target"
    
    # Safely cleanup worktrees directory
    cleanup_worktrees_dir
    
    git worktree list
    ;;
  add)
    shift
    # add subcommand processing
    branch="${1-}"
    [[ -z "$branch" ]] && { echo "‚ùå Please specify branch name: git-wt add <branch>"; exit 1; }
    create_worktree "$branch"
    ;;
  goto)
    shift
    # goto subcommand processing
    target_num="${1-}"
    [[ -z "$target_num" ]] && { echo "‚ùå Please specify number: git-wt goto <num>"; exit 1; }

    # Validate number
    if [[ ! "$target_num" =~ ^[0-9]$ ]]; then
      echo "‚ùå Invalid number. Use 0 for main repository, or 1-9 for worktrees"
      exit 1
    fi

    if [[ "$target_num" == "0" ]]; then
      # Go to main repository
      cd_command="cd \"$root\""
      if command -v pbcopy &>/dev/null; then
        echo "$cd_command" | pbcopy
        echo "‚úÖ Copied to clipboard: $cd_command"
      else
        echo "‚ö†Ô∏è pbcopy not found (macOS only feature)"
        echo "Command: $cd_command"
      fi
    else
      # Go to worktree
      target="$wroot/$target_num"
      if [[ ! -d "$target" ]]; then
        echo "‚ùå Worktree $target_num does not exist: $target"
        exit 1
      fi

      cd_command="cd \"$target\""
      if command -v pbcopy &>/dev/null; then
        echo "$cd_command" | pbcopy
        echo "‚úÖ Copied to clipboard: $cd_command"
      else
        echo "‚ö†Ô∏è pbcopy not found (macOS only feature)"
        echo "Command: $cd_command"
      fi
    fi
    ;;
  "")
    # No arguments: show selection menu
    echo "üìã Current worktrees:"
    git worktree list
    echo ""
    echo "Please select a command:"

    # Show option to go to main repository
    echo "0. goto - Copy cd command to main repository"

    # Collect available worktree numbers
    available_nums=(0)
    if [[ -d "$wroot" ]]; then
      for num in {1..9}; do
        if [[ -d "$wroot/$num" ]]; then
          echo "$num. goto - Copy cd command to worktree $num"
          available_nums+=("$num")
        fi
      done
    fi

    echo "a. add - Create new worktree"
    echo "p. pop - Remove existing worktree"
    echo "h. help - Show usage information"
    echo "q. quit - Quit without action"
    echo ""

    # Build choice prompt dynamically
    choice_options="a/p/h/q"
    if [[ ${#available_nums[@]} -gt 0 ]]; then
      num_options=$(IFS=/; echo "${available_nums[*]}")
      choice_options="$num_options/$choice_options"
    fi
    read -rp "Choice [$choice_options]: " choice

    case "$choice" in
      0)
        # Copy cd command to main repository
        cd_command="cd \"$root\""
        if command -v pbcopy &>/dev/null; then
          echo "$cd_command" | pbcopy
          echo "‚úÖ Copied to clipboard: $cd_command"
        else
          echo "‚ö†Ô∏è pbcopy not found (macOS only feature)"
          echo "Command: $cd_command"
        fi
        ;;
      [1-9])
        # Copy cd command to clipboard
        if [[ -d "$wroot/$choice" ]]; then
          cd_command="cd \"$wroot/$choice\""
          if command -v pbcopy &>/dev/null; then
            echo "$cd_command" | pbcopy
            echo "‚úÖ Copied to clipboard: $cd_command"
          else
            echo "‚ö†Ô∏è pbcopy not found (macOS only feature)"
            echo "Command: $cd_command"
          fi
        else
          echo "‚ùå Worktree $choice does not exist"
          exit 1
        fi
        ;;
      a|A)
        read -rp "Enter branch name: " branch
        [[ -z "$branch" ]] && { echo "‚ùå Branch name is empty"; exit 1; }
        create_worktree "$branch"
        ;;
      p|P)
        # Check if worktree directory exists
        [[ -d "$wroot" ]] || { echo "‚ùå Worktree directory does not exist: $wroot"; exit 1; }

        # Find maximum number
        if ! max_num=$(find_max_worktree_num); then
          echo "‚ùå No removable worktree found"
          exit 1
        fi

        target="$wroot/$max_num"

        # Check for changes and ask for confirmation if needed
        if ! check_worktree_changes "$target"; then
          exit 1
        fi

        # Remove worktree (force removal if user confirmed despite changes)
        if ! git worktree remove "$target" 2>/dev/null; then
          git worktree remove --force "$target"
        fi
        echo "‚úÖ Worktree removed: $target"

        # Safely cleanup worktrees directory
        cleanup_worktrees_dir

        git worktree list
        ;;
      h|H)
        usage
        ;;
      q|Q)
        echo "üëã Goodbye!"
        exit 0
        ;;
      *)
        echo "‚ùå Invalid selection"
        exit 1
        ;;
    esac
    ;;
  *)
    # Unknown subcommand
    echo "‚ùå Unknown subcommand: $command"
    usage
    ;;
esac

