#!/usr/bin/env bash
# git-wt  â”€ manage worktrees at ../<repo>.worktrees/<number>
set -euo pipefail

usage() {
  cat << 'EOF'
Usage: git-wt [command] [args]

Commands:
  git-wt add <branch>  Create worktree with branch
  git-wt pop [num]     Remove worktree by number (defaults to highest)
  git-wt goto <num>    Copy cd command to clipboard (0=main, 1-9=worktree)
  git-wt task [desc]   Set/show task description for current worktree
  git-wt status [-w]   Show status of all worktrees (-w: watch mode)
  git-wt               Show interactive menu

Examples:
  git-wt add feature-x  Create worktree in directory "1" with branch "feature-x"
  git-wt pop            Remove highest numbered worktree
  git-wt pop 2          Remove worktree directory "2"
  git-wt goto 0         Copy cd command to main repository
  git-wt goto 1         Copy cd command to worktree 1
  git-wt task "èªè¨¼æ©Ÿèƒ½å®Ÿè£…"  Set task description
  git-wt status         Show all worktrees with their tasks
  git-wt status -w      Watch mode (auto-refresh every 2s)
  git-wt status -w -n 5 Watch mode with 5s interval
  git-wt                Interactive menu with add/pop/help/exit options
EOF
  exit 1
}

# Sanitize branch name to prevent injection attacks
sanitize_branch_name() {
  local branch="$1"
  # Remove dangerous characters and validate
  if [[ "$branch" =~ [^a-zA-Z0-9._/-] ]]; then
    echo "âŒ Branch name contains invalid characters. Use only: a-z A-Z 0-9 . _ / -" >&2
    exit 1
  fi
  if [[ "$branch" =~ ^[.-] || "$branch" =~ [.-]$ || "$branch" =~ // ]]; then
    echo "âŒ Invalid branch name format" >&2
    exit 1
  fi
}

# Find the maximum numbered worktree directory
find_max_worktree_num() {
  local max_num=0
  [[ -d "$wroot" ]] || return 1
  
  # Enable nullglob to handle case where no files match pattern
  local nullglob_was_set=false
  shopt -q nullglob && nullglob_was_set=true
  shopt -s nullglob
  
  for dir in "$wroot"/*; do
    [[ -d "$dir" ]] || continue
    local num=$(basename "$dir")
    [[ "$num" =~ ^[1-9]$ ]] && ((num > max_num)) && max_num=$num
  done
  
  # Restore original nullglob setting
  $nullglob_was_set || shopt -u nullglob
  
  [[ $max_num -eq 0 ]] && return 1
  echo "$max_num"
}

# Check for uncommitted changes and ask for confirmation
check_worktree_changes() {
  local target="$1"

  # Change to the worktree directory and check for differences
  local has_changes=false

  # Check if directory exists and is a git worktree
  [[ -d "$target" ]] || return 0

  # Save current directory and change to worktree
  local original_pwd="$PWD"
  cd "$target" || return 0

  # Check for staged changes
  if ! git diff --cached --quiet 2>/dev/null; then
    has_changes=true
  fi

  # Check for unstaged changes
  if ! git diff --quiet 2>/dev/null; then
    has_changes=true
  fi

  # Check for untracked files
  if [[ -n "$(git ls-files --others --exclude-standard 2>/dev/null)" ]]; then
    has_changes=true
  fi

  # Return to original directory
  cd "$original_pwd"

  if [[ "$has_changes" == true ]]; then
    echo "âš ï¸ The worktree has uncommitted changes:"
    echo "   Location: $target"
    echo ""

    # Show the changes
    cd "$target"
    echo "ğŸ“„ Current status:"
    git status --short 2>/dev/null || true
    cd "$original_pwd"
    echo ""

    # Ask for confirmation
    read -rp "â“ Are you sure you want to remove this worktree? [y/N]: " confirm
    case "$confirm" in
      y|Y|yes|YES)
        echo "ğŸ—‘ï¸ Proceeding with removal..."
        return 0
        ;;
      *)
        echo "âŒ Removal cancelled"
        return 1
        ;;
    esac
  fi

  return 0
}

# Safely remove worktrees directory if it only contains numbered directories
cleanup_worktrees_dir() {
  [[ -d "$wroot" ]] || return 0

  # Check if directory contains only numbered directories (1-9) or is empty
  local has_non_numbered=false
  local has_anything=false
  local non_numbered_items=()

  # Enable dotglob to include hidden files
  local dotglob_was_set=false
  shopt -q dotglob && dotglob_was_set=true
  shopt -s dotglob

  for item in "$wroot"/*; do
    [[ -e "$item" ]] || continue
    has_anything=true

    local basename_item=$(basename "$item")
    # Skip .status directory (managed by git-wt)
    [[ "$basename_item" == ".status" ]] && continue
    if [[ ! "$basename_item" =~ ^[1-9]$ ]] || [[ ! -d "$item" ]]; then
      has_non_numbered=true
      non_numbered_items+=("$basename_item")
    fi
  done

  # Restore original dotglob setting
  $dotglob_was_set || shopt -u dotglob

  if [[ "$has_non_numbered" == true ]]; then
    echo "âš ï¸ Worktrees directory contains non-numbered files/directories:" >&2
    for item in "${non_numbered_items[@]}"; do
      echo "   - $item" >&2
    done
    echo "" >&2
    read -rp "ğŸ—‘ï¸ Remove worktrees directory and all contents? [y/N]: " confirm
    case "$confirm" in
      y|Y|yes|YES)
        rm -rf "$wroot"
        echo "âœ… Removed worktrees directory: $wroot"
        return 0
        ;;
      *)
        echo "âš ï¸ Worktrees directory kept: $wroot" >&2
        return 1
        ;;
    esac
  elif [[ "$has_anything" == false ]]; then
    # Directory is empty
    rmdir "$wroot" 2>/dev/null
    echo "ğŸ—‘ï¸ Removed empty worktrees directory: $wroot"
    return 0
  fi

  # Has numbered directories only, don't remove
  return 0
}

# Evaluate arithmetic expression with WORKTREE_NUM
# Supports: {{WORKTREE_NUM + N}}, {{WORKTREE_NUM - N}}, {{WORKTREE_NUM * N}}, {{WORKTREE_NUM / N}}, {{WORKTREE_NUM % N}}
eval_worktree_expr() {
  local expr="$1"
  local worktree_num="$2"

  # Extract operator and operand: "WORKTREE_NUM + 3000" -> "+" and "3000"
  if [[ "$expr" =~ ^WORKTREE_NUM[[:space:]]*([+*/%\-])[[:space:]]*([0-9]+)$ ]]; then
    local op="${BASH_REMATCH[1]}"
    local num="${BASH_REMATCH[2]}"
    echo $((worktree_num $op num))
  else
    return 1
  fi
}

# Substitute template variables in a file
substitute_template_variables() {
  local file="$1"
  local worktree_num="$2"
  local branch="$3"
  local worktree_path="$4"

  # Skip if file doesn't exist or is a directory
  [[ -f "$file" ]] || return 0

  # Create temporary file for substitution
  local temp_file="${file}.tmp"

  # First pass: simple variable substitutions
  sed \
    -e "s|{{WORKTREE_NUM}}|${worktree_num}|g" \
    -e "s|{{BRANCH}}|${branch}|g" \
    -e "s|{{REPO}}|${repo}|g" \
    -e "s|{{WORKTREE_PATH}}|${worktree_path}|g" \
    "$file" > "$temp_file"

  # Second pass: arithmetic expressions {{WORKTREE_NUM + N}}
  local content
  content=$(<"$temp_file")

  # Find and replace all arithmetic expressions
  while [[ "$content" =~ \{\{(WORKTREE_NUM[[:space:]]*[+*/%\-][[:space:]]*[0-9]+)\}\} ]]; do
    local full_match="${BASH_REMATCH[0]}"
    local expr="${BASH_REMATCH[1]}"
    local result
    if result=$(eval_worktree_expr "$expr" "$worktree_num"); then
      content="${content//$full_match/$result}"
    else
      break
    fi
  done

  echo "$content" > "$temp_file"

  # Replace original file with substituted version
  mv "$temp_file" "$file"
}

# Recursively substitute template variables in directory
substitute_template_variables_in_dir() {
  local dir="$1"
  local worktree_num="$2"
  local branch="$3"
  local worktree_path="$4"

  # Find all files (not directories) and substitute variables
  while IFS= read -r -d '' file; do
    substitute_template_variables "$file" "$worktree_num" "$branch" "$worktree_path"
  done < <(find "$dir" -type f -print0)
}

# Get owner/repo from git remote URL
get_remote_repo_path() {
  local remote_url
  remote_url=$(git remote get-url origin 2>/dev/null) || return 1

  # Extract owner/repo from various URL formats:
  # git@github.com:owner/repo.git
  # https://github.com/owner/repo.git
  # https://github.com/owner/repo
  if [[ "$remote_url" =~ [:/]([^/:]+)/([^/]+)$ ]]; then
    local owner="${BASH_REMATCH[1]}"
    local repo="${BASH_REMATCH[2]}"
    # Remove .git suffix if present
    repo="${repo%.git}"
    echo "$owner/$repo"
  else
    return 1
  fi
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Status management functions
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Get status directory path
get_status_dir() {
  echo "$wroot/.status"
}

# Get current worktree number from PWD
# Returns: worktree number (1-9) or empty if not in a worktree
get_current_worktree_num() {
  local current_path="$PWD"

  # Check if current path matches .worktrees/<num> pattern
  if [[ "$current_path" =~ \.worktrees/([1-9])(/|$) ]]; then
    echo "${BASH_REMATCH[1]}"
  fi
}

# Get worktree number from path
get_worktree_num_from_path() {
  local path="$1"
  if [[ "$path" =~ \.worktrees/([1-9])(/|$) ]]; then
    echo "${BASH_REMATCH[1]}"
  fi
}

# Set task for a worktree
# Usage: set_worktree_task <num> <description>
set_worktree_task() {
  local num="$1"
  local description="$2"
  local status_dir
  status_dir=$(get_status_dir)

  mkdir -p "$status_dir"

  local status_file="$status_dir/${num}.json"
  local timestamp
  timestamp=$(date +"%Y-%m-%d %H:%M:%S")

  # Get branch name for this worktree
  local branch=""
  local worktree_path="$wroot/$num"
  if [[ -d "$worktree_path" ]]; then
    branch=$(git -C "$worktree_path" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
  fi

  # Check if status file already exists (preserve first_task)
  if [[ -f "$status_file" ]]; then
    # Update last_task, status, and timestamp only
    local first_task
    first_task=$(grep -o '"first_task": *"[^"]*"' "$status_file" | sed 's/"first_task": *"\(.*\)"/\1/' || echo "")

    # If first_task is empty (old format), use current task as first_task
    [[ -z "$first_task" ]] && first_task=$(grep -o '"task": *"[^"]*"' "$status_file" | sed 's/"task": *"\(.*\)"/\1/' || echo "$description")

    cat > "$status_file" << EOF
{
  "first_task": "$first_task",
  "last_task": "$description",
  "status": "active",
  "branch": "$branch",
  "updated": "$timestamp"
}
EOF
  else
    # New file: set both first_task and last_task
    cat > "$status_file" << EOF
{
  "first_task": "$description",
  "last_task": "$description",
  "status": "active",
  "branch": "$branch",
  "updated": "$timestamp"
}
EOF
  fi
}

# Get first task for a worktree
get_worktree_first_task() {
  local num="$1"
  local status_dir
  status_dir=$(get_status_dir)
  local status_file="$status_dir/${num}.json"

  if [[ -f "$status_file" ]]; then
    local first_task
    first_task=$(grep -o '"first_task": *"[^"]*"' "$status_file" | sed 's/"first_task": *"\(.*\)"/\1/')
    # Fallback to old format
    [[ -z "$first_task" ]] && first_task=$(grep -o '"task": *"[^"]*"' "$status_file" | sed 's/"task": *"\(.*\)"/\1/')
    echo "$first_task"
  fi
}

# Get last task for a worktree
get_worktree_last_task() {
  local num="$1"
  local status_dir
  status_dir=$(get_status_dir)
  local status_file="$status_dir/${num}.json"

  if [[ -f "$status_file" ]]; then
    local last_task
    last_task=$(grep -o '"last_task": *"[^"]*"' "$status_file" | sed 's/"last_task": *"\(.*\)"/\1/')
    # Fallback to old format
    [[ -z "$last_task" ]] && last_task=$(grep -o '"task": *"[^"]*"' "$status_file" | sed 's/"task": *"\(.*\)"/\1/')
    echo "$last_task"
  fi
}

# Get task for a worktree (backward compatibility - returns last_task)
get_worktree_task() {
  get_worktree_last_task "$1"
}

# Get status for a worktree
get_worktree_status() {
  local num="$1"
  local status_dir
  status_dir=$(get_status_dir)
  local status_file="$status_dir/${num}.json"

  if [[ -f "$status_file" ]]; then
    grep -o '"status": *"[^"]*"' "$status_file" | sed 's/"status": *"\(.*\)"/\1/'
  fi
}

# Get updated timestamp for a worktree
get_worktree_updated() {
  local num="$1"
  local status_dir
  status_dir=$(get_status_dir)
  local status_file="$status_dir/${num}.json"

  if [[ -f "$status_file" ]]; then
    grep -o '"updated": *"[^"]*"' "$status_file" | sed 's/"updated": *"\(.*\)"/\1/'
  fi
}

# Format relative time from local timestamp
format_relative_time() {
  local timestamp="$1"

  # Convert timestamp to epoch seconds
  local then_epoch
  if [[ "$OSTYPE" == "darwin"* ]]; then
    then_epoch=$(date -j -f "%Y-%m-%d %H:%M:%S" "$timestamp" +%s 2>/dev/null) || return
  else
    then_epoch=$(date -d "$timestamp" +%s 2>/dev/null) || return
  fi

  local now_epoch
  now_epoch=$(date +%s)
  local diff=$((now_epoch - then_epoch))

  if [[ $diff -lt 60 ]]; then
    echo "now"
  elif [[ $diff -lt 3600 ]]; then
    echo "$((diff / 60))åˆ†å‰"
  elif [[ $diff -lt 86400 ]]; then
    echo "$((diff / 3600))æ™‚é–“å‰"
  else
    echo "$((diff / 86400))æ—¥å‰"
  fi
}

# Mark task as done
mark_worktree_done() {
  local num="$1"
  local status_dir
  status_dir=$(get_status_dir)
  local status_file="$status_dir/${num}.json"

  if [[ -f "$status_file" ]]; then
    local timestamp
    timestamp=$(date +"%Y-%m-%d %H:%M:%S")

    # Update status to done
    if [[ "$OSTYPE" == "darwin"* ]]; then
      sed -i '' "s/\"status\": *\"[^\"]*\"/\"status\": \"done\"/" "$status_file"
      sed -i '' "s/\"updated\": *\"[^\"]*\"/\"updated\": \"$timestamp\"/" "$status_file"
    else
      sed -i "s/\"status\": *\"[^\"]*\"/\"status\": \"done\"/" "$status_file"
      sed -i "s/\"updated\": *\"[^\"]*\"/\"updated\": \"$timestamp\"/" "$status_file"
    fi
    return 0
  fi
  return 1
}

# Mark task as asking (waiting for user selection)
mark_worktree_asking() {
  local num="$1"
  local status_dir
  status_dir=$(get_status_dir)
  local status_file="$status_dir/${num}.json"

  if [[ -f "$status_file" ]]; then
    local timestamp
    timestamp=$(date +"%Y-%m-%d %H:%M:%S")

    if [[ "$OSTYPE" == "darwin"* ]]; then
      sed -i '' "s/\"status\": *\"[^\"]*\"/\"status\": \"asking\"/" "$status_file"
      sed -i '' "s/\"updated\": *\"[^\"]*\"/\"updated\": \"$timestamp\"/" "$status_file"
    else
      sed -i "s/\"status\": *\"[^\"]*\"/\"status\": \"asking\"/" "$status_file"
      sed -i "s/\"updated\": *\"[^\"]*\"/\"updated\": \"$timestamp\"/" "$status_file"
    fi
    return 0
  else
    mkdir -p "$status_dir"
    local timestamp
    timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    cat > "$status_file" << EOF
{
  "task": "",
  "status": "asking",
  "branch": "",
  "updated": "$timestamp"
}
EOF
    return 0
  fi
  return 1
}

# Mark task as waiting for input
mark_worktree_waiting() {
  local num="$1"
  local status_dir
  status_dir=$(get_status_dir)
  local status_file="$status_dir/${num}.json"

  if [[ -f "$status_file" ]]; then
    local timestamp
    timestamp=$(date +"%Y-%m-%d %H:%M:%S")

    # Update status to waiting
    if [[ "$OSTYPE" == "darwin"* ]]; then
      sed -i '' "s/\"status\": *\"[^\"]*\"/\"status\": \"waiting\"/" "$status_file"
      sed -i '' "s/\"updated\": *\"[^\"]*\"/\"updated\": \"$timestamp\"/" "$status_file"
    else
      sed -i "s/\"status\": *\"[^\"]*\"/\"status\": \"waiting\"/" "$status_file"
      sed -i "s/\"updated\": *\"[^\"]*\"/\"updated\": \"$timestamp\"/" "$status_file"
    fi
    return 0
  else
    # Create new status file with waiting status
    mkdir -p "$status_dir"
    local timestamp
    timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    cat > "$status_file" << EOF
{
  "task": "",
  "status": "waiting",
  "branch": "",
  "updated": "$timestamp"
}
EOF
    return 0
  fi
  return 1
}

# Clear task (remove status file)
clear_worktree_task() {
  local num="$1"
  local status_dir
  status_dir=$(get_status_dir)
  local status_file="$status_dir/${num}.json"

  if [[ -f "$status_file" ]]; then
    rm "$status_file"
  fi
}

# Set Claude's last message for a worktree
set_worktree_claude_msg() {
  local num="$1"
  local message="$2"
  local status_dir
  status_dir=$(get_status_dir)
  local status_file="$status_dir/${num}.json"

  if [[ -f "$status_file" ]]; then
    # Escape special characters for JSON
    message="${message//\\/\\\\}"
    message="${message//\"/\\\"}"
    message="${message//$'\n'/\\n}"

    # Check if claude_msg field exists
    if grep -q '"claude_msg"' "$status_file" 2>/dev/null; then
      # Update existing field
      if [[ "$OSTYPE" == "darwin"* ]]; then
        sed -i '' "s/\"claude_msg\": *\"[^\"]*\"/\"claude_msg\": \"$message\"/" "$status_file"
      else
        sed -i "s/\"claude_msg\": *\"[^\"]*\"/\"claude_msg\": \"$message\"/" "$status_file"
      fi
    else
      # Add new field before the closing brace
      if [[ "$OSTYPE" == "darwin"* ]]; then
        sed -i '' "s/}$/,\n  \"claude_msg\": \"$message\"\n}/" "$status_file"
      else
        sed -i "s/}$/,\n  \"claude_msg\": \"$message\"\n}/" "$status_file"
      fi
    fi
  fi
}

# Get Claude's last message for a worktree
get_worktree_claude_msg() {
  local num="$1"
  local status_dir
  status_dir=$(get_status_dir)
  local status_file="$status_dir/${num}.json"

  if [[ -f "$status_file" ]]; then
    grep -o '"claude_msg": *"[^"]*"' "$status_file" 2>/dev/null | sed 's/"claude_msg": *"\(.*\)"/\1/' || true
  fi
}

# Show status of all worktrees
show_all_status() {
  echo "git-wt ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ ($repo)"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

  local has_worktrees=false

  # Show main repo (0)
  local main_branch
  main_branch=$(git -C "$root" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "-")
  echo ""
  echo "[0] $main_branch (main)"

  # Show worktrees 1-9
  for num in 1 2 3 4 5 6 7 8 9; do
    local worktree_path="$wroot/$num"
    [[ -d "$worktree_path" ]] || continue

    has_worktrees=true

    local branch
    branch=$(git -C "$worktree_path" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "-")

    local first_task
    first_task=$(get_worktree_first_task "$num")

    local last_task
    last_task=$(get_worktree_last_task "$num")

    local status
    status=$(get_worktree_status "$num")

    local updated
    updated=$(get_worktree_updated "$num")
    local relative_time=""
    if [[ -n "$updated" ]]; then
      relative_time=$(format_relative_time "$updated") || relative_time=""
    fi

    # Build header line: [num] branch (time)
    echo ""
    if [[ -n "$relative_time" ]]; then
      echo "[$num] $branch ($relative_time)"
    else
      echo "[$num] $branch"
    fi

    # Show status indicator
    local status_icon=""
    case "$status" in
      asking)  status_icon="ğŸ™‹ é¸æŠå¾…ã¡" ;;
      waiting) status_icon="â³ å…¥åŠ›å¾…ã¡" ;;
      active)  status_icon="â— ä½œæ¥­ä¸­" ;;
      done)    status_icon="âœ“ å®Œäº†" ;;
    esac

    if [[ -n "$status_icon" ]]; then
      echo "    $status_icon"
    fi

    # Show first task (full)
    if [[ -n "$first_task" ]]; then
      echo "    ğŸ“‹ $first_task"
    fi

    # Show last task (truncated) if different from first
    if [[ -n "$last_task" && "$last_task" != "$first_task" ]]; then
      # Truncate to ~60 chars
      local truncated_last="${last_task:0:60}"
      [[ ${#last_task} -gt 60 ]] && truncated_last="${truncated_last}..."
      echo "    â””â”€ $truncated_last"
    fi

    # Show Claude's last message
    local claude_msg
    claude_msg=$(get_worktree_claude_msg "$num")
    if [[ -n "$claude_msg" ]]; then
      echo "    ğŸ¤– $claude_msg"
    fi

    # If no tasks at all
    if [[ -z "$first_task" && -z "$last_task" && -z "$claude_msg" ]]; then
      echo "    (ã‚¿ã‚¹ã‚¯ãªã—)"
    fi
  done

  if [[ "$has_worktrees" == false ]]; then
    echo ""
    echo "(ãƒ¯ãƒ¼ã‚¯ãƒ„ãƒªãƒ¼ãªã—)"
  fi

  echo ""
}

# Find templates directory (repo-local or global)
find_templates_dir() {
  local repo_templates="$root/.git-wt"

  if [[ -d "$repo_templates" ]]; then
    echo "$repo_templates"
    return 0
  fi

  # Try global templates with owner/repo structure
  local remote_path
  if remote_path=$(get_remote_repo_path); then
    local global_templates="$HOME/.git-wt/$remote_path"
    if [[ -d "$global_templates" ]]; then
      echo "$global_templates"
      return 0
    fi
  fi

  return 1
}

# Copy files from .git-wt/ directory to worktree with variable substitution
copy_files_to_worktree() {
  local target="$1"
  local worktree_num="$2"
  local branch="$3"

  # Find templates directory
  local templates_dir
  if ! templates_dir=$(find_templates_dir); then
    return 0
  fi

  local copied_count=0
  local is_global=false
  [[ "$templates_dir" == "$HOME/.git-wt/"* ]] && is_global=true

  if [[ "$is_global" == true ]]; then
    echo "ğŸ“‚ Using global templates: $templates_dir"
  else
    echo "ğŸ“‚ Using repo templates: $templates_dir"
  fi

  # Copy all files from templates directory preserving structure
  while IFS= read -r -d '' src_file; do
    # Get relative path from templates directory
    local rel_path="${src_file#$templates_dir/}"
    local dest_file="$target/$rel_path"

    # Create directory structure
    mkdir -p "$(dirname "$dest_file")"

    # Copy file
    cp "$src_file" "$dest_file"

    # Check if file contains template variables before substitution
    local has_variables=false
    if grep -q '{{WORKTREE_NUM}}\|{{BRANCH}}\|{{REPO}}\|{{WORKTREE_PATH}}' "$src_file" 2>/dev/null; then
      has_variables=true
    fi

    # Substitute template variables
    substitute_template_variables "$dest_file" "$worktree_num" "$branch" "$target"

    if [[ "$has_variables" == true ]]; then
      echo "ğŸ“„ $rel_path (with variable substitution)"
    else
      echo "ğŸ“„ $rel_path"
    fi
    copied_count=$((copied_count + 1))
  done < <(find "$templates_dir" -type f -not -name '.DS_Store' -print0)

  if [[ $copied_count -gt 0 ]]; then
    echo "âœ… Copied $copied_count file(s) from templates"
  fi
}

# Create new worktree with given branch name
create_worktree() {
  local branch="$1"

  # Sanitize branch name
  sanitize_branch_name "$branch"

  # Find next available number (maximum 9)
  local next_num=1
  while [[ $next_num -le 9 && -e "$wroot/$next_num" ]]; do
    ((next_num++))
  done

  if [[ $next_num -gt 9 ]]; then
    echo "âŒ Maximum 9 worktrees allowed. Please remove one first with: git-wt pop" >&2
    exit 1
  fi

  local target="$wroot/$next_num"
  mkdir -p "$wroot"

  # Track if branch exists remotely, otherwise create new
  if git show-ref --verify --quiet "refs/heads/$branch"; then
    git worktree add "$target" "$branch" || { rmdir "$target" 2>/dev/null; exit 1; }
    echo "âœ… Worktree created: $target (existing branch: $branch)"
  elif git ls-remote --exit-code --heads origin "$branch" &>/dev/null; then
    git worktree add "$target" "origin/$branch" || { rmdir "$target" 2>/dev/null; exit 1; }
    echo "âœ… Worktree created: $target (remote branch: $branch)"
  else
    git worktree add -b "$branch" "$target" || { rmdir "$target" 2>/dev/null; exit 1; }
    echo "âœ… Worktree created: $target (new branch: $branch)"
  fi

  # Copy files from configuration
  copy_files_to_worktree "$target" "$next_num" "$branch"

  git worktree list

  # Ask if user wants to copy cd command to clipboard
  echo ""
  echo "ğŸ“ To navigate to the new directory: cd \"$target\""
  read -rp "ğŸ“‹ Copy cd command to clipboard? [Y/n]: " copy_confirm
  case "$copy_confirm" in
    n|N|no|NO)
      # Don't copy
      ;;
    *)
      # Copy to clipboard (default is yes)
      copy_cd_command "$target"
      ;;
  esac
}

# Copy cd command to clipboard
copy_cd_command() {
  local path="$1"
  local cd_command="cd \"$path\""

  if command -v pbcopy &>/dev/null; then
    echo "$cd_command" | pbcopy
    echo "âœ… Copied to clipboard: $cd_command"
  else
    echo "âš ï¸ pbcopy not found (macOS only feature)"
    echo "Command: $cd_command"
  fi
}

# â‘  Check if this is a Git repository
git rev-parse --is-inside-work-tree &>/dev/null || {
  echo "âŒ Not a Git repository" >&2; exit 1; }

# â‘¡ Calculate paths (common)
# Get main repository path from git worktree list (first entry is always the main repo)
root="$(git worktree list | head -n1 | awk '{print $1}')"
repo="$(basename "$root")"
# Normalize the wroot path by using cd and pwd
wroot="$(cd "$root/.." && pwd)/${repo}.worktrees"

# â‘¢ Subcommand processing
command="${1-}"
case "$command" in
  -h|--help) usage ;;
  pop)
    shift
    # pop subcommand processing
    target_num="${1-}"
    
    # Check if worktree directory exists
    [[ -d "$wroot" ]] || { echo "âŒ Worktree directory does not exist: $wroot"; exit 1; }
    
    # If no number specified, find the maximum number
    if [[ -z "$target_num" ]]; then
      if ! target_num=$(find_max_worktree_num); then
        echo "âŒ No removable worktree found"
        exit 1
      fi
    fi
    
    target="$wroot/$target_num"
    [[ -d "$target" ]] || { echo "âŒ Worktree does not exist: $target"; exit 1; }

    # Check for changes and ask for confirmation if needed
    if ! check_worktree_changes "$target"; then
      exit 1
    fi

    # Remove worktree (force removal if user confirmed despite changes)
    if ! git worktree remove "$target" 2>/dev/null; then
      git worktree remove --force "$target"
    fi
    echo "âœ… Worktree removed: $target"

    # Remove status file for this worktree
    clear_worktree_task "$target_num"

    # Safely cleanup worktrees directory
    cleanup_worktrees_dir
    
    git worktree list
    ;;
  add)
    shift
    # add subcommand processing
    branch="${1-}"
    [[ -z "$branch" ]] && { echo "âŒ Please specify branch name: git-wt add <branch>"; exit 1; }
    create_worktree "$branch"
    ;;
  goto)
    shift
    # goto subcommand processing
    target_num="${1-}"
    [[ -z "$target_num" ]] && { echo "âŒ Please specify number: git-wt goto <num>"; exit 1; }

    # Validate number (0-9 only for git-wt managed worktrees)
    if [[ ! "$target_num" =~ ^[0-9]$ ]]; then
      echo "âŒ Invalid number. Use 0 for main repository, or 1-9 for worktrees"
      exit 1
    fi

    if [[ "$target_num" == "0" ]]; then
      # Go to main repository
      copy_cd_command "$root"
    else
      # Go to git-wt managed worktree
      target="$wroot/$target_num"
      if [[ ! -d "$target" ]]; then
        echo "âŒ Worktree $target_num does not exist: $target"
        exit 1
      fi
      copy_cd_command "$target"
    fi
    ;;
  task)
    shift
    # task subcommand processing
    task_desc="${1-}"

    # Get current worktree number
    wt_num=$(get_current_worktree_num)

    if [[ -z "$wt_num" ]]; then
      echo "âŒ Not in a git-wt managed worktree"
      echo "   Current directory must be inside: <repo>.worktrees/<num>"
      exit 1
    fi

    if [[ -z "$task_desc" ]]; then
      # Show current task
      current_task=$(get_worktree_task "$wt_num")
      if [[ -n "$current_task" ]]; then
        echo "ğŸ“‹ Worktree $wt_num: $current_task"
      else
        echo "ğŸ“‹ Worktree $wt_num: (no task set)"
      fi
    else
      # Set task
      set_worktree_task "$wt_num" "$task_desc"
      echo "âœ… Task set for worktree $wt_num: $task_desc"
    fi
    ;;
  status)
    shift
    # status subcommand processing
    watch_mode=false
    watch_interval=2

    while [[ $# -gt 0 ]]; do
      case "$1" in
        -w|--watch)
          watch_mode=true
          shift
          ;;
        -n|--interval)
          watch_interval="$2"
          shift 2
          ;;
        *)
          echo "âŒ Unknown option: $1"
          exit 1
          ;;
      esac
    done

    if [[ "$watch_mode" == true ]]; then
      # Watch mode: refresh every N seconds
      trap 'printf "\033[?25h"; echo ""; echo "ğŸ‘‹ Stopped watching"; exit 0' INT
      printf "\033[?25l"  # Hide cursor
      while true; do
        # Move cursor to top and clear screen
        printf "\033[H\033[J"
        echo "ğŸ‘€ git-wt status --watch (Ctrl+C to stop)"
        echo ""
        show_all_status
        echo ""
        echo "ğŸ• Updated: $(date '+%H:%M:%S') (interval: ${watch_interval}s)"
        sleep "$watch_interval"
      done
    else
      show_all_status
    fi
    ;;
  waiting)
    # waiting subcommand processing
    wt_num=$(get_current_worktree_num)

    if [[ -z "$wt_num" ]]; then
      echo "âŒ Not in a git-wt managed worktree"
      exit 1
    fi

    mark_worktree_waiting "$wt_num"
    echo "â³ Marked as waiting for input (worktree $wt_num)"
    ;;
  asking)
    # asking subcommand processing
    wt_num=$(get_current_worktree_num)

    if [[ -z "$wt_num" ]]; then
      echo "âŒ Not in a git-wt managed worktree"
      exit 1
    fi

    mark_worktree_asking "$wt_num"
    echo "ğŸ™‹ Marked as asking for selection (worktree $wt_num)"
    ;;
  claude-msg)
    shift
    # claude-msg subcommand processing (internal use by hooks)
    msg="${1-}"
    wt_num=$(get_current_worktree_num)

    if [[ -z "$wt_num" ]]; then
      exit 0  # Silent exit if not in worktree
    fi

    if [[ -n "$msg" ]]; then
      set_worktree_claude_msg "$wt_num" "$msg"
    fi
    ;;
  "")
    # No arguments: show selection menu
    echo "ğŸ“‹ Current worktrees:"
    git worktree list
    echo ""
    echo "Please select a command:"

    # Parse git worktree list and assign numbers
    declare -A worktree_paths
    available_nums=()
    next_manual_num=50
    is_first=true

    while IFS= read -r line; do
      # Extract path (first field before double spaces)
      wt_path=$(echo "$line" | awk '{print $1}')

      # Check if this is main repository (first entry)
      if [[ "$is_first" == "true" ]]; then
        worktree_paths[0]="$wt_path"
        echo "0. Copy 'cd $wt_path' to clipboard"
        available_nums+=(0)
        is_first=false
      # Check if path matches our worktree pattern: ../<repo>.worktrees/<num>
      elif [[ "$wt_path" =~ $wroot/([0-9])$ ]]; then
        num="${BASH_REMATCH[1]}"
        worktree_paths[$num]="$wt_path"
        echo "$num. Copy 'cd $wt_path' to clipboard"
        available_nums+=("$num")
      else
        # Manual worktree, assign number 50+
        worktree_paths[$next_manual_num]="$wt_path"
        echo "$next_manual_num. Copy 'cd $wt_path' to clipboard"
        available_nums+=("$next_manual_num")
        ((next_manual_num++))
      fi
    done < <(git worktree list)

    echo ""
    echo "a. add - Create new worktree"
    echo "p. pop - Remove existing worktree"
    echo "h. help - Show usage information"
    echo "q. quit - Quit without action"
    echo ""

    # Build choice prompt dynamically
    choice_options="a/p/h/q"
    if [[ ${#available_nums[@]} -gt 0 ]]; then
      num_options=$(IFS=/; echo "${available_nums[*]}")
      choice_options="$num_options/$choice_options"
    fi
    read -rp "Choice [$choice_options]: " choice

    case "$choice" in
      [0-9]|[0-9][0-9])
        # Copy cd command for any numbered worktree
        if [[ -n "${worktree_paths[$choice]}" ]]; then
          copy_cd_command "${worktree_paths[$choice]}"
        else
          echo "âŒ Worktree $choice does not exist"
          exit 1
        fi
        ;;
      a|A)
        read -rp "Enter branch name: " branch
        [[ -z "$branch" ]] && { echo "âŒ Branch name is empty"; exit 1; }
        create_worktree "$branch"
        ;;
      p|P)
        # Check if worktree directory exists
        [[ -d "$wroot" ]] || { echo "âŒ Worktree directory does not exist: $wroot"; exit 1; }

        # Find maximum number
        if ! max_num=$(find_max_worktree_num); then
          echo "âŒ No removable worktree found"
          exit 1
        fi

        target="$wroot/$max_num"

        # Check for changes and ask for confirmation if needed
        if ! check_worktree_changes "$target"; then
          exit 1
        fi

        # Remove worktree (force removal if user confirmed despite changes)
        if ! git worktree remove "$target" 2>/dev/null; then
          git worktree remove --force "$target"
        fi
        echo "âœ… Worktree removed: $target"

        # Safely cleanup worktrees directory
        cleanup_worktrees_dir

        git worktree list
        ;;
      h|H)
        usage
        ;;
      q|Q)
        echo "ğŸ‘‹ Goodbye!"
        exit 0
        ;;
      *)
        echo "âŒ Invalid selection"
        exit 1
        ;;
    esac
    ;;
  *)
    # Unknown subcommand
    echo "âŒ Unknown subcommand: $command"
    usage
    ;;
esac

